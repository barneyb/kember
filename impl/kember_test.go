package kember

import (
  "testing"
  "fmt"
)

func TestRunes(t *testing.T) {
  s := "Hello, \u2381!"

  fmt.Print("string: ")
  fmt.Println(s)
  fmt.Print("        ")
  fmt.Println(string(s))

  fmt.Print("bytes:  ")
  fmt.Println([]byte(s))
  fmt.Print("        ")
  fmt.Println(string([]byte(s)))

  fmt.Print("runes:  ")
  fmt.Println([]rune(s))
  fmt.Print("        ")
  fmt.Println(string([]rune(s)))
}

func TestValid(t *testing.T) {
  cases := []struct {
    in string
    want bool
  }{
    {"", false},
    {"00000000000000000000000000000000", true},
    {"0000000000000000000000000000000", false},
    {"000000000000000000000000000000000", false},
    {"00000000000000000123456789abcdef", true},
    {"0000000000000000000000000000000g", false},
    {"0000000000000000000000000000000.", false},
  }
  for _, c := range cases {
    got := Valid(c.in)
    if got != c.want {
      t.Errorf("Valid(%v) gave %q (want %q)", c.in, got, c.want)
    }
  }
}

func TestIncrement(t *testing.T) {
  cases := []struct {
    in, want string
  }{
    {"00000000000000000000000000000000", "00000000000000000000000000000001"},
    {"00000000000000000000000000000001", "00000000000000000000000000000002"},
    {"00000000000000000000000000000002", "00000000000000000000000000000003"},
    {"00000000000000000000000000000003", "00000000000000000000000000000004"},
    {"00000000000000000000000000000004", "00000000000000000000000000000005"},
    {"00000000000000000000000000000005", "00000000000000000000000000000006"},
    {"00000000000000000000000000000006", "00000000000000000000000000000007"},
    {"00000000000000000000000000000007", "00000000000000000000000000000008"},
    {"00000000000000000000000000000008", "00000000000000000000000000000009"},
    {"00000000000000000000000000000009", "0000000000000000000000000000000a"},
    {"0000000000000000000000000000000a", "0000000000000000000000000000000b"},
    {"0000000000000000000000000000000b", "0000000000000000000000000000000c"},
    {"0000000000000000000000000000000c", "0000000000000000000000000000000d"},
    {"0000000000000000000000000000000d", "0000000000000000000000000000000e"},
    {"0000000000000000000000000000000e", "0000000000000000000000000000000f"},
    {"0000000000000000000000000000000f", "00000000000000000000000000000010"},
    {"00000000000000000000000000000f00", "00000000000000000000000000000f01"},
    {"00000000000000000000000000000fff", "00000000000000000000000000001000"},
    {"00000000000000000000000000009fff", "0000000000000000000000000000a000"},
    {"ffffffffffffffffffffffffffffffff", "00000000000000000000000000000000"}, // overflow
  }
  for _, c := range cases {
    runes := []rune(c.in)
    increment(runes)
    got := string(runes)
    if got != c.want {
      t.Errorf("increment(%v) gave %q (want %q)", c.in, got, c.want)
    }
  }
}

func TestNext(t *testing.T) {
  cases := []struct {
    in, want rune
  }{
    {'0', '1'},
    {'1', '2'},
    {'2', '3'},
    {'3', '4'},
    {'4', '5'},
    {'5', '6'},
    {'6', '7'},
    {'7', '8'},
    {'8', '9'},
    {'9', 'a'},
    {'a', 'b'},
    {'b', 'c'},
    {'c', 'd'},
    {'d', 'e'},
    {'e', 'f'},
    {'f', '0'},
  }
  for _, c := range cases {
    got := next(c.in)
    if got != c.want {
      t.Errorf("next(%v) gave %q (want %q)", c.in, got, c.want)
    }
  }
}
